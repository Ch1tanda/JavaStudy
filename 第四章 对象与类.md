## 4.1 面向对象程序设计概述

+ 概述

  + 面向对象的程序由对象组成的，每个对象包含**对用户公开的特定功能**和**隐藏的实现部分**
  + 传统的结构化设计通过一系列过程（算法）来求解问题。一旦确定了这些过程算法，就要开始考虑存储数据的适当方式。这就是Pascal语言的设计者的一本书命名为《算法+数据结构=程序》的原因。在这本书中，算法是第一位的，数据结构是第二位的，但是面向对象却调换了这个次序，将数据放在第一位，然后考虑操作数据的算法。
  + 对于小规模问题，将其分解为过程开发方式比较理想。面向对象更加适合解决规模较大的问题。比如一个web浏览器

+ #### 4.1.1 类

  + **类（class）是构造对象的模板或蓝图，由类<u>构造(construct)</u>对象的过程称为创建类的<u>实例</u>(instance)**
  + 封装(encapsulation，有时称为数据隐藏)是处理对象的一个重要概念。将数据和行为组合在一个包中，并对对象的使用者隐藏具体的实现方法。**对象中的数据称为实例字段（instance field），操作数据的过程称为方法（method）**。作为一个类的实例，特定对象都有一组特定的实例字段值。**这些值的集合就是这个对象的当前状态（state）**
  + 实现封装的关键在于，绝对不能让类中的方法直接访问其它类的实例字段，只能通过对象的方法与对象交互，提高重用性和可靠性
  + OOP的另一个原则就是：可以通过扩展其他类来构建新类（Object）。在拓展一个新类时，新类会获得被拓展的类的全部属性和方法。只需要提供新的方法和新的数据字段即可。**通过拓展一个类来建立另一个类的过程称为继承（inheritance）**

+ #### 4.1.2 对象

  + 对象的三个主要特性
    + 对象的行为：可以对对象完成哪些操作，可以对对象应用哪些方法
    + 对象的状态：调用那些方法时，对象会如何响应
    + 对象的标识：如何区分具有相同行为和状态的对象
  + 对象的状态必须通过方法来改变，否则就破坏了封装性

+ #### 4.1.3 识别类

  + 学会从实际情况判断哪些属于一个类

+ #### 4.1.4 类之间的关系

  + 依赖(use)：一个类的方法使用或者操纵另一个类的对象，这个要尽可能少，即减少类之间的耦合
  + 聚合(has)：包含，例如一个Order类包含Item类 要使用Item的信息
  + 继承(is)：表示一个更特殊的类和一个更一般的类之间的关系

## 4.2 使用预定义类

+ Math类没有数据，没有实例字段，没有状态，只有方法

+ #### 4.2.1 对象与对象变量

  + 在Java中，要使用构造器（constructor，或称构造函数）构造新实例

  + 构造器的名字与类名相同 

  + 用Date()来说明

    + new Date() 创建了一个对象

    + 可以用一个对象变量来存放这个对象 Date today = new Date(); 这里可以称为，对象变量today引用了Date类型的对象

    + 如果单纯只是Date tomorrow，它只是一个Date对象变量，没有引用任何Date对象，所以不能使用Date方法，因此，要么给它一个初始化变量，要么让它引用一个已存在的变量

    + ```java
      Date today = new Date();
      Date tomorrow;
      String s = tomorrow.toString();//not yet
      tomorrow = new Date();//√
      tomorrow = today;//√
      ```

  + 在Java中，任何**对象变量的值**都是对存储在**另外一个地方的某个对象**的**引用**

  + 可以显式的把一个对象变量设置为null，表示这个对象变量没有引用任何对象

+ #### 4.2.2 Java库中的LocalDate类

  + Date类是用来表示时间点的，LocalDate类用日历表示法表示日期

  + 不要使用构造器构造LocalDate类，而是使用静态工厂方法(factory method)，它会代表你调用构造器

  + ```java
    LocalDate theYear = LocalDate.of(1999.12.31);
    LocalDate aThousandDaysLater = theYear.plusDays(1000);
    ```

+ #### 4.2.3 更改器方法与访问器方法

  + 更改器方法：调用该方法，会修改对象的方法称作更改器方法
  + 访问器方法：调用该方法，不会修改对象的方法称作访问器方法
  
+ #### 4.3.3  

  + public 意味所有方法都可以调用
  + private以为只有同类方法才可以调用
  + 类包含的实例字段通常属于某个类类型

+ #### 4.3.4 构造器

  + 和类同名
  + 不止一个构造器
  + 可以有多个参数
  + 无返回值 没有void int 等等
  + 构造器总是伴随new操作符一起调用

+ #### 4.3.5 用var声明局部变量

  + 如果可以直接从变量的初始值推导出它们的类型，就可以用var关键字声明局部变量
  
  + ```java
    var aLinkedList = new LinkedList(6);
    ```
  
  + var只能用于声明局部变量，参数和字段的类型必须声明
  
+ #### 4.3.6 使用null引用

  + 定义一个类的时候，尽量要知道哪些字段可能为null，并且在这个值为null的时候调用方法来解决它们

  + ```java
    if( n == null) name = "unknown"; else name=n;
    name = Objects.requireNonNullElse(n,"unknown");	//宽容型 把n变成unknown然后赋值
    Objects.requireNonNull(n,"The name cannot be null");	//严格型，直接抛出指针异常
    name = n;
    ```

+ #### 4.3.7 隐式参数和显式参数

  + ```java
    public Employee(String n, double s) {
    	super();
    	this.name = n;
    	this.salary = s;
    }
    ```

  + 显式参数（explict）在上面的例子中，即方法括号中声明的参数n s

  + 隐式参数表示在方法中使用，但是没有写在方法参数中也没有在方法体内声明的变量 例如name salary 一般尽量用this来标识

+ #### 4.3.8 封装的优点

  + 字段访问器：只返回实例字段的值的访问器方法
  + 实例字段的一般方法
    + 一个private的数据字段
    + 一个public的字段访问器方法
    + 一个public的字段更改器方法
  + 优点一：可以改变内部实现，除了该类的方法之外，不会影响其它代码
  + 优点二：更改器方法可以完成错误检查
  + 警告：不要返回可变对象引用的访问器方法 比如Date一个对象 返回Date 因为Date自身有方法可以修改对象值 但是在这个引用了Date的类中 不允许修改，破坏了封装性

+ #### 4.3.9 基于类的访问权限

  + 一个类的方法可以访问该类中所有private的字段

+ #### 4.3.10 私有方法

  + 某个公有方法需要多个子方法，可以把这些子方法设置为辅助的私有方法 从4.3.9可得 公共方法也可以调取私有方法

+ #### 4.3.11 final实例字段

  + 如果设置了某个实例字段为final 那么这个字段必须在构造函数中进行初始化 并且以后再也不能修改 无set方法
  + 不要用final设置可变类 比如StringBuilder

